#!/usr/bin/env bash
#
# Plaster - Cross-platform clipboard service client
# A FILO (First In, Last Out) clipboard that stores multiple entries
#

set -euo pipefail

# Default values
PLASTER_CONFIG="${HOME}/.plaster/config.yaml"
SERVER_URL="http://localhost:9321"
API_KEY=""
HELP_TEXT="Usage: plaster [OPTION]

A FILO clipboard service client.

OPTIONS:
  (no args)                 Get the latest clipboard entry
  -l, --list                List all clipboard entries (first 50 chars each)
  -n, --entry <index>       Get specific clipboard entry by index (1-based)
  -c, --clear               Clear all clipboard entries
  --setup                   Interactive setup (configure server URL and get API key)
  --new-api                 Generate a new API key
  --new-server-url <url>    Change the server URL
  --api                     Display current API key
  --url                     Display current server URL
  --install                 Install plaster to /usr/local/bin (requires sudo)
  --uninstall               Uninstall plaster from /usr/local/bin (requires sudo)
  --config <path>           Use custom config file path
  -h, --help                Show this help message

EXAMPLES:
  plaster --install                  # Install to /usr/local/bin
  plaster --uninstall                # Remove from /usr/local/bin
  plaster --setup                    # Initial setup (server URL + API key)
  plaster --api                      # Show current API key
  plaster --url                      # Show current server URL
  echo 'my text' | plaster           # Push text to clipboard
  plaster                            # Get latest entry
  plaster --list                     # List all entries
  plaster -n 1                       # Get 1st entry
  plaster -n 3                       # Get 3rd entry
  plaster --clear                    # Clear clipboard
  plaster --new-api                  # Generate new API key
  plaster --new-server-url <url>     # Change server URL
"

# Function to generate a new API key from server
generate_api_key() {
    local response
    local http_code
    response=$(curl -s -w "\n%{http_code}" -X POST "$SERVER_URL/auth/generate" \
        -H "Content-Type: application/json" 2>&1)

    http_code=$(echo "$response" | tail -n 1)
    response=$(echo "$response" | sed '$d')

    if [[ "$http_code" != "200" ]]; then
        echo "Error: Failed to generate API key (HTTP $http_code)" >&2
        echo "Server response: $response" >&2
        exit 1
    fi

    if echo "$response" | jq -e '.api_key' > /dev/null 2>&1; then
        echo "$response" | jq -r '.api_key'
    else
        echo "Error: Failed to parse API key from response" >&2
        echo "Server response: $response" >&2
        exit 1
    fi
}

# Function to regenerate API key (when expired)
regenerate_api_key() {
    local new_key
    new_key=$(generate_api_key)
    API_KEY="$new_key"

    # Update config file
    sed -i.bak "s/api_key:.*/api_key: \"$new_key\"/" "$PLASTER_CONFIG"
    rm -f "$PLASTER_CONFIG.bak"

    echo "✓ New API key generated: $new_key" >&2
}

# Function to load configuration
load_config() {
    if [[ ! -f "$PLASTER_CONFIG" ]]; then
        echo "Error: Config file not found at $PLASTER_CONFIG" >&2
        echo "Run 'plaster --setup' to initialize." >&2
        exit 1
    fi

    # Extract values from YAML
    SERVER_URL=$(grep "server_url:" "$PLASTER_CONFIG" | head -1 | sed 's/.*: //' | tr -d ' "' || echo "http://localhost:9321")
    API_KEY=$(grep "api_key:" "$PLASTER_CONFIG" | head -1 | sed 's/.*: //' | tr -d ' "' || echo "")

    if [[ -z "$API_KEY" ]]; then
        echo "Error: No API key found in config. Run 'plaster --new-api' to generate one." >&2
        exit 1
    fi
}

# Function to setup configuration interactively
setup_config() {
    echo "╔═════════════════════════════════════════╗"
    echo "║     Plaster Initial Setup               ║"
    echo "╚═════════════════════════════════════════╝"
    echo ""

    # Create config directory
    mkdir -p "$(dirname "$PLASTER_CONFIG")"

    # Prompt for server URL
    while true; do
        read -p "Server URL (e.g., http://localhost:9321): " SERVER_URL
        if [[ -z "$SERVER_URL" ]]; then
            echo "Error: Server URL cannot be empty"
            continue
        fi
        break
    done

    echo ""
    echo "Generating API key from server..."
    API_KEY=$(generate_api_key)

    # Create config file
    cat > "$PLASTER_CONFIG" << EOF
# Plaster Configuration File

server_url: "$SERVER_URL"
api_key: "$API_KEY"
port: 9321
max_entries: 100
persistence: true
backup_file: "~/.plaster/backup.json"
max_entry_size_mb: 10
max_total_size_mb: 500
rate_limit_requests: 100
rate_limit_window_seconds: 60
EOF

    chmod 600 "$PLASTER_CONFIG"

    echo ""
    echo "✓ Configuration saved to $PLASTER_CONFIG"
    echo "✓ Server URL: $SERVER_URL"
    echo "✓ API Key: $API_KEY"
    echo ""
    echo "Setup complete! You can now use Plaster:"
    echo "  echo 'my text' | plaster    # Push text"
    echo "  plaster                     # Get latest entry"
    echo "  plaster --list              # List all entries"
}

# Function to generate new API key
generate_new_api_key() {
    load_config

    echo "Generating new API key from $SERVER_URL..."
    local new_key
    new_key=$(generate_api_key)

    # Update config file
    sed -i.bak "s/api_key:.*/api_key: \"$new_key\"/" "$PLASTER_CONFIG"
    rm -f "$PLASTER_CONFIG.bak"

    echo "✓ New API key generated: $new_key"
}

# Function to change server URL
change_server_url() {
    local new_url="$1"

    if [[ ! -f "$PLASTER_CONFIG" ]]; then
        echo "Error: Config file not found. Run 'plaster --setup' first." >&2
        exit 1
    fi

    # Update config file
    sed -i.bak "s|server_url:.*|server_url: \"$new_url\"|" "$PLASTER_CONFIG"
    rm -f "$PLASTER_CONFIG.bak"

    echo "✓ Server URL updated to: $new_url"
}

# Function to check if stdin is being piped
has_stdin() {
    [[ ! -t 0 ]]
}

# Function to show help
show_help() {
    echo "$HELP_TEXT"
}

# Function to install plaster
install_plaster() {
    local install_path="/usr/local/bin/plaster"
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    local script_path="$script_dir/plaster"

    echo "Installing Plaster to $install_path..."

    if [[ ! -f "$script_path" ]]; then
        echo "Error: Could not find plaster script at $script_path" >&2
        exit 1
    fi

    sudo cp "$script_path" "$install_path"
    sudo chmod +x "$install_path"

    echo "✓ Plaster installed successfully to $install_path"
    echo "You can now run 'plaster' from anywhere!"
}

# Function to uninstall plaster
uninstall_plaster() {
    local install_path="/usr/local/bin/plaster"

    echo "Uninstalling Plaster from $install_path..."

    if [[ ! -f "$install_path" ]]; then
        echo "Error: Plaster is not installed at $install_path" >&2
        exit 1
    fi

    sudo rm "$install_path"

    echo "✓ Plaster uninstalled successfully"
}

# Function to display current API key
show_api_key() {
    load_config
    echo "$API_KEY"
}

# Function to display current server URL
show_server_url() {
    load_config
    echo "$SERVER_URL"
}

# Function to push text
push_text() {
    local text="$1"
    local response
    local http_code
    response=$(curl -s -w "\n%{http_code}" -X POST "$SERVER_URL/push" \
        -H "Content-Type: application/json" \
        -H "X-API-Key: $API_KEY" \
        -d "{\"text\": $(echo "$text" | jq -Rs .)}" 2>&1)

    http_code=$(echo "$response" | tail -n 1)
    response=$(echo "$response" | sed '$d')

    # Check for expired/invalid key (401)
    if [[ "$http_code" == "401" ]]; then
        echo "API key expired. Generating new one..." >&2
        regenerate_api_key
        # Retry with new key
        push_text "$text"
        return
    fi

    if echo "$response" | grep -q "status.*ok"; then
        echo "✓ Text pushed to clipboard" >&2
    else
        echo "Error: Failed to push text" >&2
        echo "$response" >&2
        exit 1
    fi
}

# Helper to make API calls with 401 handling
api_call() {
    local method="$1"
    local endpoint="$2"
    local data="$3"
    local response
    local http_code

    if [[ -z "$data" ]]; then
        response=$(curl -s -w "\n%{http_code}" -X "$method" "$SERVER_URL$endpoint" \
            -H "X-API-Key: $API_KEY" 2>&1)
    else
        response=$(curl -s -w "\n%{http_code}" -X "$method" "$SERVER_URL$endpoint" \
            -H "Content-Type: application/json" \
            -H "X-API-Key: $API_KEY" \
            -d "$data" 2>&1)
    fi

    http_code=$(echo "$response" | tail -n 1)
    response=$(echo "$response" | sed '$d')

    # Check for expired key
    if [[ "$http_code" == "401" ]]; then
        echo "API key expired. Generating new one..." >&2
        regenerate_api_key
        # Retry with new key
        api_call "$method" "$endpoint" "$data"
        return
    fi

    echo "$response"
}

# Function to get latest entry
get_latest() {
    local response
    response=$(api_call GET /peek)

    if echo "$response" | grep -q '"status".*"ok"'; then
        echo "$response" | jq -r '.text'
    else
        echo "Error: Failed to get clipboard entry" >&2
        echo "$response" >&2
        exit 1
    fi
}

# Function to list all entries
list_entries() {
    local response
    response=$(curl -s -X GET "$SERVER_URL/list" \
        -H "X-API-Key: $API_KEY" 2>&1)

    if echo "$response" | grep -q '"status".*"ok"'; then
        local count
        count=$(echo "$response" | jq -r '.count')
        echo "Clipboard entries ($count total):" >&2
        echo "$response" | jq -r '.entries[] | ., ""' | nl
    else
        echo "Error: Failed to list entries" >&2
        echo "$response" >&2
        exit 1
    fi
}

# Function to get specific entry
get_entry() {
    local user_index=$1
    # Convert from 1-based (user input) to 0-based (server)
    local server_index=$((user_index - 1))

    if [[ $server_index -lt 0 ]]; then
        echo "Error: Entry index must be 1 or greater" >&2
        exit 1
    fi

    local response
    response=$(curl -s -X GET "$SERVER_URL/entry/$server_index" \
        -H "X-API-Key: $API_KEY" 2>&1)

    if echo "$response" | grep -q '"status".*"ok"'; then
        echo "$response" | jq -r '.text'
    else
        echo "Error: Failed to get entry at index $user_index" >&2
        echo "$response" >&2
        exit 1
    fi
}

# Function to clear clipboard
clear_clipboard() {
    local response
    response=$(curl -s -X DELETE "$SERVER_URL/clear" \
        -H "X-API-Key: $API_KEY" 2>&1)

    if echo "$response" | grep -q '"status".*"ok"'; then
        echo "✓ Clipboard cleared" >&2
    else
        echo "Error: Failed to clear clipboard" >&2
        echo "$response" >&2
        exit 1
    fi
}

# Main logic
main() {
    # Parse command-line arguments
    if [[ $# -eq 0 ]]; then
        # No arguments - check if stdin is being piped
        if has_stdin; then
            # Text is being piped - load config and push it
            load_config
            local input
            input=$(cat)
            push_text "$input"
        else
            # No arguments and no stdin - get latest entry
            load_config
            get_latest
        fi
    else
        case "$1" in
            -h|--help)
                show_help
                ;;
            --install)
                install_plaster
                exit 0
                ;;
            --uninstall)
                uninstall_plaster
                exit 0
                ;;
            --setup)
                setup_config
                ;;
            --new-api)
                generate_new_api_key
                ;;
            --new-server-url)
                if [[ $# -lt 2 ]]; then
                    echo "Error: --new-server-url requires a URL argument" >&2
                    exit 1
                fi
                change_server_url "$2"
                ;;
            --api)
                show_api_key
                ;;
            --url)
                show_server_url
                ;;
            -l|--list)
                load_config
                list_entries
                ;;
            -n|--entry)
                if [[ $# -lt 2 ]]; then
                    echo "Error: -n/--entry requires an index argument" >&2
                    exit 1
                fi
                load_config
                get_entry "$2"
                ;;
            -c|--clear)
                load_config
                clear_clipboard
                ;;
            --config)
                if [[ $# -lt 2 ]]; then
                    echo "Error: --config requires a path argument" >&2
                    exit 1
                fi
                PLASTER_CONFIG="$2"
                shift 2
                # Recursively call main with remaining args
                main "$@"
                return
                ;;
            *)
                echo "Error: Unknown option '$1'" >&2
                show_help
                exit 1
                ;;
        esac
    fi
}

main "$@"
