#!/usr/bin/env bash
#
# Plaster - Cross-platform clipboard service client
# A FILO (First In, Last Out) clipboard that stores multiple entries
#

set -euo pipefail

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Default values - use script directory if not installed
# If installed to /usr/local/bin, use ~/.plaster
if [[ "$SCRIPT_DIR" == "/usr/local/bin" ]]; then
    PLASTER_CONFIG="${HOME}/.plaster/config.yaml"
else
    PLASTER_CONFIG="${SCRIPT_DIR}/config.yaml"
fi

SERVER_URL="http://localhost:9321"
API_KEY=""
HELP_TEXT="Usage: plaster [OPTION]

A FILO clipboard service client.

OPTIONS:
  (no args)                 Get the latest clipboard entry
  -l, --list                List all clipboard entries (first 50 chars each)
  -n, --entry <index>       Get specific clipboard entry by index (1-based)
  -c, --clear               Clear all clipboard entries
  --setup                   Interactive setup (configure server URL and get API key)
  --new-api [KEY]           Generate a new API key, or set to KEY if provided
  --new-server-url <url>    Change the server URL
  --api                     Display current API key
  --url                     Display current server URL
  --qrcode                  Generate QR code for web UI with current API key
  --install                 Install plaster to /usr/local/bin (requires sudo)
  --uninstall               Uninstall plaster from /usr/local/bin (requires sudo)
  --config <path>           Use custom config file path
  -h, --help                Show this help message

EXAMPLES:
  plaster --install                  # Install to /usr/local/bin
  plaster --uninstall                # Remove from /usr/local/bin
  plaster --setup                    # Initial setup (server URL + API key)
  plaster --api                      # Show current API key
  plaster --url                      # Show current server URL
  plaster --qrcode                   # Generate QR code for web UI link
  echo 'my text' | plaster           # Push text to clipboard
  plaster                            # Get latest entry
  plaster --list                     # List all entries
  plaster -n 1                       # Get 1st entry
  plaster -n 3                       # Get 3rd entry
  plaster --clear                    # Clear clipboard
  plaster --new-api                  # Generate new API key
  plaster --new-api plaster_xyz      # Set API key to plaster_xyz
  plaster --new-server-url <url>     # Change server URL
"

# Function to generate a new API key from server
generate_api_key() {
    local response
    local http_code
    response=$(curl -s -w "\n%{http_code}" -X POST "$SERVER_URL/auth/generate" \
        -H "Content-Type: application/json" 2>&1)

    http_code=$(echo "$response" | tail -n 1)
    response=$(echo "$response" | sed '$d')

    if [[ "$http_code" != "200" ]]; then
        echo "Error: Failed to generate API key (HTTP $http_code)" >&2
        echo "Server response: $response" >&2
        exit 1
    fi

    # Try jq first (preferred method)
    if command -v jq &> /dev/null && echo "$response" | jq -e '.api_key' > /dev/null 2>&1; then
        echo "$response" | jq -r '.api_key'
    # Fallback to grep/cut if jq fails or isn't available
    elif grep -q '"api_key"' <<< "$response"; then
        echo "$response" | grep -o '"api_key":"[^"]*"' | cut -d'"' -f4
    else
        echo "Error: Failed to parse API key from response" >&2
        echo "Server response: $response" >&2
        echo "Response length: ${#response} bytes" >&2
        exit 1
    fi
}

# Function to regenerate API key (when expired)
regenerate_api_key() {
    local new_key
    new_key=$(generate_api_key)
    API_KEY="$new_key"

    # Update config file
    sed -i.bak "s/api_key:.*/api_key: \"$new_key\"/" "$PLASTER_CONFIG"
    rm -f "$PLASTER_CONFIG.bak"

    echo "✓ New API key generated: $new_key" >&2
}

# Function to load configuration
load_config() {
    if [[ ! -f "$PLASTER_CONFIG" ]]; then
        echo "Error: Config file not found at $PLASTER_CONFIG" >&2
        echo "Run 'plaster --setup' to initialize." >&2
        exit 1
    fi

    # Extract values from YAML
    SERVER_URL=$(grep "server_url:" "$PLASTER_CONFIG" | head -1 | sed 's/.*: //' | tr -d ' "' || echo "http://localhost:9321")
    API_KEY=$(grep "api_key:" "$PLASTER_CONFIG" | head -1 | sed 's/.*: //' | tr -d ' "' || echo "")

    if [[ -z "$API_KEY" ]]; then
        echo "Error: No API key found in config. Run 'plaster --new-api' to generate one." >&2
        exit 1
    fi
}

# Function to setup configuration interactively
setup_config() {
    echo "╔═════════════════════════════════════════╗"
    echo "║     Plaster Initial Setup               ║"
    echo "╚═════════════════════════════════════════╝"
    echo ""

    # Create config directory
    mkdir -p "$(dirname "$PLASTER_CONFIG")"

    # Prompt for server URL
    while true; do
        read -p "Server URL (e.g., http://localhost:9321): " SERVER_URL
        if [[ -z "$SERVER_URL" ]]; then
            echo "Error: Server URL cannot be empty"
            continue
        fi
        break
    done

    echo ""
    echo "Generating API key from server..."
    API_KEY=$(generate_api_key)

    # Create config file
    cat > "$PLASTER_CONFIG" << EOF
# Plaster Client Configuration
# Only contains client-side settings

server_url: "$SERVER_URL"
api_key: "$API_KEY"
EOF

    chmod 600 "$PLASTER_CONFIG"

    echo ""
    echo "✓ Configuration saved to $PLASTER_CONFIG"
    echo "✓ Server URL: $SERVER_URL"
    echo "✓ API Key: $API_KEY"
    echo ""
    echo "Setup complete! You can now use Plaster:"
    echo "  echo 'my text' | plaster    # Push text"
    echo "  plaster                     # Get latest entry"
    echo "  plaster --list              # List all entries"
    echo ""
    echo "To make 'plaster' available from anywhere, install it:"
    echo "  plaster --install           # Install to /usr/local/bin"
}

# Function to generate or set new API key
generate_new_api_key() {
    local provided_key="$1"
    load_config

    local new_key
    if [[ -z "$provided_key" ]]; then
        echo "Generating new API key from $SERVER_URL..."
        new_key=$(generate_api_key)
        echo "✓ New API key generated: $new_key"
    else
        new_key="$provided_key"
        echo "✓ API key set to: $new_key"
    fi

    # Update config file
    sed -i.bak "s/api_key:.*/api_key: \"$new_key\"/" "$PLASTER_CONFIG"
    rm -f "$PLASTER_CONFIG.bak"
}

# Function to change server URL
change_server_url() {
    local new_url="$1"

    if [[ ! -f "$PLASTER_CONFIG" ]]; then
        echo "Error: Config file not found. Run 'plaster --setup' first." >&2
        exit 1
    fi

    # Update config file
    sed -i.bak "s|server_url:.*|server_url: \"$new_url\"|" "$PLASTER_CONFIG"
    rm -f "$PLASTER_CONFIG.bak"

    echo "✓ Server URL updated to: $new_url"
}

# Function to check if stdin is being piped
has_stdin() {
    [[ ! -t 0 ]]
}

# Function to copy text to system clipboard
copy_to_clipboard() {
    local text="$1"

    # Try different clipboard commands (macOS, Linux, Windows WSL)
    if command -v pbcopy &> /dev/null; then
        # macOS
        echo -n "$text" | pbcopy
    elif command -v xclip &> /dev/null; then
        # Linux with xclip
        echo -n "$text" | xclip -selection clipboard
    elif command -v xsel &> /dev/null; then
        # Linux with xsel
        echo -n "$text" | xsel --clipboard --input
    elif command -v clip.exe &> /dev/null; then
        # Windows WSL
        echo -n "$text" | clip.exe
    fi
}

# Function to show help
show_help() {
    echo "$HELP_TEXT"
}

# Function to install plaster
install_plaster() {
    local install_path="/usr/local/bin/plaster"
    local config_dir="${HOME}/.plaster"
    local old_config="${SCRIPT_DIR}/config.yaml"
    local new_config="${config_dir}/config.yaml"

    echo "Installing Plaster to $install_path..."

    if [[ ! -f "$SCRIPT_DIR/plaster" ]]; then
        echo "Error: Could not find plaster script at $SCRIPT_DIR/plaster" >&2
        exit 1
    fi

    sudo cp "$SCRIPT_DIR/plaster" "$install_path"
    sudo chmod +x "$install_path"

    # Create config directory for installed version
    mkdir -p "$config_dir"

    # Migrate config from script directory to ~/.plaster if it exists there
    if [[ -f "$old_config" ]]; then
        echo "Migrating config from $old_config to $new_config..."
        cp "$old_config" "$new_config"
        chmod 600 "$new_config"
        echo "✓ Config migrated to $new_config"
    fi

    echo "✓ Plaster installed successfully to $install_path"
    echo "✓ Config directory: $config_dir"
    echo "You can now run 'plaster' from anywhere!"
}

# Function to uninstall plaster
uninstall_plaster() {
    local install_path="/usr/local/bin/plaster"
    local config_dir="${HOME}/.plaster"

    echo "Uninstalling Plaster from $install_path..."

    if [[ ! -f "$install_path" ]]; then
        echo "Error: Plaster is not installed at $install_path" >&2
        exit 1
    fi

    sudo rm "$install_path"

    # Ask to remove config directory
    if [[ -d "$config_dir" ]]; then
        read -p "Remove config directory $config_dir? (y/N): " -r remove_config
        if [[ "$remove_config" =~ ^[Yy]$ ]]; then
            rm -rf "$config_dir"
            echo "✓ Config directory removed"
        else
            echo "Config directory preserved at $config_dir"
        fi
    fi

    echo "✓ Plaster uninstalled successfully"
}

# Function to display current API key
show_api_key() {
    load_config
    echo "$API_KEY"
}

# Function to display current server URL
show_server_url() {
    load_config
    echo "$SERVER_URL"
}

# Function to generate and display QR code for web UI
generate_qrcode() {
    load_config

    # Create the web UI URL with API key
    local web_url="$SERVER_URL/?api_key=$API_KEY"

    echo "Generating QR code for: $web_url" >&2
    echo "" >&2

    # Check if qr command is available (qrencode)
    if command -v qr &> /dev/null; then
        # Use 'qr' tool (simpler output)
        qr "$web_url"
    elif command -v qrencode &> /dev/null; then
        # Use 'qrencode' tool (more options)
        qrencode -t ANSI256 "$web_url"
    else
        echo "Error: QR code tools not found" >&2
        echo "Install 'qr' or 'qrencode' package:" >&2
        echo "  Ubuntu/Debian: sudo apt install qrencode" >&2
        echo "  macOS: brew install qrencode" >&2
        echo "" >&2
        echo "Alternatively, scan this URL manually:" >&2
        echo "$web_url" >&2
        exit 1
    fi
}

# Function to push text
push_text() {
    local text="$1"
    local response
    local http_code
    response=$(curl -s -w "\n%{http_code}" -X POST "$SERVER_URL/push" \
        -H "Content-Type: application/json" \
        -H "X-API-Key: $API_KEY" \
        -d "{\"text\": $(echo "$text" | jq -Rs .)}" 2>&1)

    http_code=$(echo "$response" | tail -n 1)
    response=$(echo "$response" | sed '$d')

    # Check for expired/invalid key (401)
    if [[ "$http_code" == "401" ]]; then
        echo "API key expired. Generating new one..." >&2
        regenerate_api_key
        # Retry with new key
        push_text "$text"
        return
    fi

    if echo "$response" | grep -q "status.*ok"; then
        echo "✓ Text pushed to clipboard" >&2
    else
        echo "Error: Failed to push text" >&2
        echo "$response" >&2
        exit 1
    fi
}

# Helper to make API calls with 401 handling
api_call() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    local response
    local http_code

    if [[ -z "$data" ]]; then
        response=$(curl -s -w "\n%{http_code}" -X "$method" "$SERVER_URL$endpoint" \
            -H "X-API-Key: $API_KEY" 2>&1)
    else
        response=$(curl -s -w "\n%{http_code}" -X "$method" "$SERVER_URL$endpoint" \
            -H "Content-Type: application/json" \
            -H "X-API-Key: $API_KEY" \
            -d "$data" 2>&1)
    fi

    http_code=$(echo "$response" | tail -n 1)
    response=$(echo "$response" | sed '$d')

    # Check for expired key
    if [[ "$http_code" == "401" ]]; then
        echo "API key expired. Generating new one..." >&2
        regenerate_api_key
        # Retry with new key
        api_call "$method" "$endpoint" "$data"
        return
    fi

    echo "$response"
}

# Function to get latest entry
get_latest() {
    local response
    local text
    response=$(api_call GET /peek)

    if echo "$response" | grep -q '"status".*"ok"'; then
        text=$(echo "$response" | jq -r '.text')
        echo "$text"
        # Copy to clipboard if not on headless client
        copy_to_clipboard "$text"
    else
        echo "Error: Failed to get clipboard entry" >&2
        echo "$response" >&2
        exit 1
    fi
}

# Function to list all entries
list_entries() {
    local response
    response=$(curl -s -X GET "$SERVER_URL/list" \
        -H "X-API-Key: $API_KEY" 2>&1)

    if echo "$response" | grep -q '"status".*"ok"'; then
        local count
        count=$(echo "$response" | jq -r '.count')
        echo "Clipboard entries ($count total):" >&2
        echo "$response" | jq -r '.entries[] | ., ""' | nl
    else
        echo "Error: Failed to list entries" >&2
        echo "$response" >&2
        exit 1
    fi
}

# Function to get specific entry
get_entry() {
    local user_index=$1
    # Convert from 1-based (user input) to 0-based (server)
    local server_index=$((user_index - 1))

    if [[ $server_index -lt 0 ]]; then
        echo "Error: Entry index must be 1 or greater" >&2
        exit 1
    fi

    local response
    local text
    response=$(curl -s -X GET "$SERVER_URL/entry/$server_index" \
        -H "X-API-Key: $API_KEY" 2>&1)

    if echo "$response" | grep -q '"status".*"ok"'; then
        text=$(echo "$response" | jq -r '.text')
        echo "$text"
        # Copy to clipboard if not on headless client
        copy_to_clipboard "$text"
    else
        echo "Error: Failed to get entry at index $user_index" >&2
        echo "$response" >&2
        exit 1
    fi
}

# Function to clear clipboard
clear_clipboard() {
    local response
    response=$(curl -s -X DELETE "$SERVER_URL/clear" \
        -H "X-API-Key: $API_KEY" 2>&1)

    if echo "$response" | grep -q '"status".*"ok"'; then
        echo "✓ Clipboard cleared" >&2
    else
        echo "Error: Failed to clear clipboard" >&2
        echo "$response" >&2
        exit 1
    fi
}

# Main logic
main() {
    # Parse command-line arguments
    if [[ $# -eq 0 ]]; then
        # No arguments - check if stdin is being piped
        if has_stdin; then
            # Text is being piped - load config and push it
            load_config
            local input
            input=$(cat)
            push_text "$input"
        else
            # No arguments and no stdin - get latest entry
            load_config
            get_latest
        fi
    else
        case "$1" in
            -h|--help)
                show_help
                ;;
            --install)
                install_plaster
                exit 0
                ;;
            --uninstall)
                uninstall_plaster
                exit 0
                ;;
            --setup)
                setup_config
                ;;
            --new-api)
                if [[ $# -gt 1 && "$2" != -* ]]; then
                    generate_new_api_key "$2"
                else
                    generate_new_api_key ""
                fi
                ;;
            --new-server-url)
                if [[ $# -lt 2 ]]; then
                    echo "Error: --new-server-url requires a URL argument" >&2
                    exit 1
                fi
                change_server_url "$2"
                ;;
            --api)
                show_api_key
                ;;
            --url)
                show_server_url
                ;;
            --qrcode)
                generate_qrcode
                ;;
            -l|--list)
                load_config
                list_entries
                ;;
            -n|--entry)
                if [[ $# -lt 2 ]]; then
                    echo "Error: -n/--entry requires an index argument" >&2
                    exit 1
                fi
                load_config
                get_entry "$2"
                ;;
            -c|--clear)
                load_config
                clear_clipboard
                ;;
            --config)
                if [[ $# -lt 2 ]]; then
                    echo "Error: --config requires a path argument" >&2
                    exit 1
                fi
                PLASTER_CONFIG="$2"
                shift 2
                # Recursively call main with remaining args
                main "$@"
                return
                ;;
            *)
                echo "Error: Unknown option '$1'" >&2
                show_help
                exit 1
                ;;
        esac
    fi
}

main "$@"
